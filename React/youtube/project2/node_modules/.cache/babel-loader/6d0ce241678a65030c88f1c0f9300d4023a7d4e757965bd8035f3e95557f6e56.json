{"ast":null,"code":"import { __assign, __spreadArray, __read } from 'tslib';\nimport sync, { cancelSync } from 'framesync';\nimport { motionValue } from '../value/index.mjs';\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\nimport { variantPriorityOrder } from './utils/animation-state.mjs';\nimport { createLifecycles } from './utils/lifecycles.mjs';\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\nimport { checkIfControllingVariants, checkIfVariantNode, isVariantLabel } from './utils/variants.mjs';\nvar visualElement = function (_a) {\n  var _b = _a.treeType,\n    treeType = _b === void 0 ? \"\" : _b,\n    build = _a.build,\n    getBaseTarget = _a.getBaseTarget,\n    makeTargetAnimatable = _a.makeTargetAnimatable,\n    measureViewportBox = _a.measureViewportBox,\n    renderInstance = _a.render,\n    readValueFromInstance = _a.readValueFromInstance,\n    removeValueFromRenderState = _a.removeValueFromRenderState,\n    sortNodePosition = _a.sortNodePosition,\n    scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n  return function (_a, options) {\n    var parent = _a.parent,\n      props = _a.props,\n      presenceId = _a.presenceId,\n      blockInitialAnimation = _a.blockInitialAnimation,\n      visualState = _a.visualState,\n      shouldReduceMotion = _a.shouldReduceMotion;\n    if (options === void 0) {\n      options = {};\n    }\n    var isMounted = false;\n    var latestValues = visualState.latestValues,\n      renderState = visualState.renderState;\n    /**\n     * The instance of the render-specific node that will be hydrated by the\n     * exposed React ref. So for example, this visual element can host a\n     * HTMLElement, plain object, or Three.js object. The functions provided\n     * in VisualElementConfig allow us to interface with this instance.\n     */\n    var instance;\n    /**\n     * Manages the subscriptions for a visual element's lifecycle, for instance\n     * onRender\n     */\n    var lifecycles = createLifecycles();\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n    var values = new Map();\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n    var valueSubscriptions = new Map();\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n    var prevMotionValues = {};\n    /**\n     * When values are removed from all animation props we need to search\n     * for a fallback value to animate to. These values are tracked in baseTarget.\n     */\n    var baseTarget = __assign({}, latestValues);\n    // Internal methods ========================\n    /**\n     * On mount, this will be hydrated with a callback to disconnect\n     * this visual element from its parent on unmount.\n     */\n    var removeFromVariantTree;\n    /**\n     * Render the element with the latest styles outside of the React\n     * render lifecycle\n     */\n    function render() {\n      if (!instance || !isMounted) return;\n      triggerBuild();\n      renderInstance(instance, renderState, props.style, element.projection);\n    }\n    function triggerBuild() {\n      build(element, renderState, latestValues, options, props);\n    }\n    function update() {\n      lifecycles.notifyUpdate(latestValues);\n    }\n    /**\n     *\n     */\n    function bindToMotionValue(key, value) {\n      var removeOnChange = value.onChange(function (latestValue) {\n        latestValues[key] = latestValue;\n        props.onUpdate && sync.update(update, false, true);\n      });\n      var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n      valueSubscriptions.set(key, function () {\n        removeOnChange();\n        removeOnRenderRequest();\n      });\n    }\n    /**\n     * Any motion values that are provided to the element when created\n     * aren't yet bound to the element, as this would technically be impure.\n     * However, we iterate through the motion values and set them to the\n     * initial values for this component.\n     *\n     * TODO: This is impure and we should look at changing this to run on mount.\n     * Doing so will break some tests but this isn't neccessarily a breaking change,\n     * more a reflection of the test.\n     */\n    var initialMotionValues = scrapeMotionValuesFromProps(props);\n    for (var key in initialMotionValues) {\n      var value = initialMotionValues[key];\n      if (latestValues[key] !== undefined && isMotionValue(value)) {\n        value.set(latestValues[key], false);\n      }\n    }\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n    var isControllingVariants = checkIfControllingVariants(props);\n    var isVariantNode = checkIfVariantNode(props);\n    var element = __assign(__assign({\n      treeType: treeType,\n      /**\n       * This is a mirror of the internal instance prop, which keeps\n       * VisualElement type-compatible with React's RefObject.\n       */\n      current: null,\n      /**\n       * The depth of this visual element within the visual element tree.\n       */\n      depth: parent ? parent.depth + 1 : 0,\n      parent: parent,\n      children: new Set(),\n      /**\n       *\n       */\n      presenceId: presenceId,\n      shouldReduceMotion: shouldReduceMotion,\n      /**\n       * If this component is part of the variant tree, it should track\n       * any children that are also part of the tree. This is essentially\n       * a shadow tree to simplify logic around how to stagger over children.\n       */\n      variantChildren: isVariantNode ? new Set() : undefined,\n      /**\n       * Whether this instance is visible. This can be changed imperatively\n       * by the projection tree, is analogous to CSS's visibility in that\n       * hidden elements should take up layout, and needs enacting by the configured\n       * render function.\n       */\n      isVisible: undefined,\n      /**\n       * Normally, if a component is controlled by a parent's variants, it can\n       * rely on that ancestor to trigger animations further down the tree.\n       * However, if a component is created after its parent is mounted, the parent\n       * won't trigger that mount animation so the child needs to.\n       *\n       * TODO: This might be better replaced with a method isParentMounted\n       */\n      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),\n      /**\n       * This can be set by AnimatePresence to force components that mount\n       * at the same time as it to mount as if they have initial={false} set.\n       */\n      blockInitialAnimation: blockInitialAnimation,\n      /**\n       * Determine whether this component has mounted yet. This is mostly used\n       * by variant children to determine whether they need to trigger their\n       * own animations on mount.\n       */\n      isMounted: function () {\n        return Boolean(instance);\n      },\n      mount: function (newInstance) {\n        isMounted = true;\n        instance = element.current = newInstance;\n        if (element.projection) {\n          element.projection.mount(newInstance);\n        }\n        if (isVariantNode && parent && !isControllingVariants) {\n          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n        }\n        values.forEach(function (value, key) {\n          return bindToMotionValue(key, value);\n        });\n        parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n        element.setProps(props);\n      },\n      /**\n       *\n       */\n      unmount: function () {\n        var _a;\n        (_a = element.projection) === null || _a === void 0 ? void 0 : _a.unmount();\n        cancelSync.update(update);\n        cancelSync.render(render);\n        valueSubscriptions.forEach(function (remove) {\n          return remove();\n        });\n        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n        parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n        lifecycles.clearAllListeners();\n        instance = undefined;\n        isMounted = false;\n      },\n      /**\n       * Add a child visual element to our set of children.\n       */\n      addVariantChild: function (child) {\n        var _a;\n        var closestVariantNode = element.getClosestVariantNode();\n        if (closestVariantNode) {\n          (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n          return function () {\n            return closestVariantNode.variantChildren.delete(child);\n          };\n        }\n      },\n      sortNodePosition: function (other) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (!sortNodePosition || treeType !== other.treeType) return 0;\n        return sortNodePosition(element.getInstance(), other.getInstance());\n      },\n      /**\n       * Returns the closest variant node in the tree starting from\n       * this visual element.\n       */\n      getClosestVariantNode: function () {\n        return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n      },\n      /**\n       * Expose the latest layoutId prop.\n       */\n      getLayoutId: function () {\n        return props.layoutId;\n      },\n      /**\n       * Returns the current instance.\n       */\n      getInstance: function () {\n        return instance;\n      },\n      /**\n       * Get/set the latest static values.\n       */\n      getStaticValue: function (key) {\n        return latestValues[key];\n      },\n      setStaticValue: function (key, value) {\n        return latestValues[key] = value;\n      },\n      /**\n       * Returns the latest motion value state. Currently only used to take\n       * a snapshot of the visual element - perhaps this can return the whole\n       * visual state\n       */\n      getLatestValues: function () {\n        return latestValues;\n      },\n      /**\n       * Set the visiblity of the visual element. If it's changed, schedule\n       * a render to reflect these changes.\n       */\n      setVisibility: function (visibility) {\n        if (element.isVisible === visibility) return;\n        element.isVisible = visibility;\n        element.scheduleRender();\n      },\n      /**\n       * Make a target animatable by Popmotion. For instance, if we're\n       * trying to animate width from 100px to 100vw we need to measure 100vw\n       * in pixels to determine what we really need to animate to. This is also\n       * pluggable to support Framer's custom value types like Color,\n       * and CSS variables.\n       */\n      makeTargetAnimatable: function (target, canMutate) {\n        if (canMutate === void 0) {\n          canMutate = true;\n        }\n        return makeTargetAnimatable(element, target, props, canMutate);\n      },\n      /**\n       * Measure the current viewport box with or without transforms.\n       * Only measures axis-aligned boxes, rotate and skew must be manually\n       * removed with a re-render to work.\n       */\n      measureViewportBox: function () {\n        return measureViewportBox(instance, props);\n      },\n      // Motion values ========================\n      /**\n       * Add a motion value and bind it to this visual element.\n       */\n      addValue: function (key, value) {\n        // Remove existing value if it exists\n        if (element.hasValue(key)) element.removeValue(key);\n        values.set(key, value);\n        latestValues[key] = value.get();\n        bindToMotionValue(key, value);\n      },\n      /**\n       * Remove a motion value and unbind any active subscriptions.\n       */\n      removeValue: function (key) {\n        var _a;\n        values.delete(key);\n        (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n        valueSubscriptions.delete(key);\n        delete latestValues[key];\n        removeValueFromRenderState(key, renderState);\n      },\n      /**\n       * Check whether we have a motion value for this key\n       */\n      hasValue: function (key) {\n        return values.has(key);\n      },\n      /**\n       * Get a motion value for this key. If called with a default\n       * value, we'll create one if none exists.\n       */\n      getValue: function (key, defaultValue) {\n        var value = values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n          value = motionValue(defaultValue);\n          element.addValue(key, value);\n        }\n        return value;\n      },\n      /**\n       * Iterate over our motion values.\n       */\n      forEachValue: function (callback) {\n        return values.forEach(callback);\n      },\n      /**\n       * If we're trying to animate to a previously unencountered value,\n       * we need to check for it in our state and as a last resort read it\n       * directly from the instance (which might have performance implications).\n       */\n      readValue: function (key) {\n        var _a;\n        return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options);\n      },\n      /**\n       * Set the base target to later animate back to. This is currently\n       * only hydrated on creation and when we first read a value.\n       */\n      setBaseTarget: function (key, value) {\n        baseTarget[key] = value;\n      },\n      /**\n       * Find the base target for a value thats been removed from all animation\n       * props.\n       */\n      getBaseTarget: function (key) {\n        if (getBaseTarget) {\n          var target = getBaseTarget(props, key);\n          if (target !== undefined && !isMotionValue(target)) return target;\n        }\n        return baseTarget[key];\n      }\n    }, lifecycles), {\n      /**\n       * Build the renderer state based on the latest visual state.\n       */\n      build: function () {\n        triggerBuild();\n        return renderState;\n      },\n      /**\n       * Schedule a render on the next animation frame.\n       */\n      scheduleRender: function () {\n        sync.render(render, false, true);\n      },\n      /**\n       * Synchronously fire render. It's prefered that we batch renders but\n       * in many circumstances, like layout measurement, we need to run this\n       * synchronously. However in those instances other measures should be taken\n       * to batch reads/writes.\n       */\n      syncRender: render,\n      /**\n       * Update the provided props. Ensure any newly-added motion values are\n       * added to our map, old ones removed, and listeners updated.\n       */\n      setProps: function (newProps) {\n        if (newProps.transformTemplate || props.transformTemplate) {\n          element.scheduleRender();\n        }\n        props = newProps;\n        lifecycles.updatePropListeners(newProps);\n        prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n      },\n      getProps: function () {\n        return props;\n      },\n      // Variants ==============================\n      /**\n       * Returns the variant definition with a given name.\n       */\n      getVariant: function (name) {\n        var _a;\n        return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name];\n      },\n      /**\n       * Returns the defined default transition on this component.\n       */\n      getDefaultTransition: function () {\n        return props.transition;\n      },\n      getTransformPagePoint: function () {\n        return props.transformPagePoint;\n      },\n      /**\n       * Used by child variant nodes to get the closest ancestor variant props.\n       */\n      getVariantContext: function (startAtParent) {\n        if (startAtParent === void 0) {\n          startAtParent = false;\n        }\n        if (startAtParent) return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n        if (!isControllingVariants) {\n          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n          if (props.initial !== undefined) {\n            context_1.initial = props.initial;\n          }\n          return context_1;\n        }\n        var context = {};\n        for (var i = 0; i < numVariantProps; i++) {\n          var name_1 = variantProps[i];\n          var prop = props[name_1];\n          if (isVariantLabel(prop) || prop === false) {\n            context[name_1] = prop;\n          }\n        }\n        return context;\n      }\n    });\n    return element;\n  };\n};\nvar variantProps = __spreadArray([\"initial\"], __read(variantPriorityOrder), false);\nvar numVariantProps = variantProps.length;\nexport { visualElement };","map":{"version":3,"names":["__assign","__spreadArray","__read","sync","cancelSync","motionValue","isMotionValue","variantPriorityOrder","createLifecycles","updateMotionValuesFromProps","checkIfControllingVariants","checkIfVariantNode","isVariantLabel","visualElement","_a","_b","treeType","build","getBaseTarget","makeTargetAnimatable","measureViewportBox","renderInstance","render","readValueFromInstance","removeValueFromRenderState","sortNodePosition","scrapeMotionValuesFromProps","options","parent","props","presenceId","blockInitialAnimation","visualState","shouldReduceMotion","isMounted","latestValues","renderState","instance","lifecycles","values","Map","valueSubscriptions","prevMotionValues","baseTarget","removeFromVariantTree","triggerBuild","style","element","projection","update","notifyUpdate","bindToMotionValue","key","value","removeOnChange","onChange","latestValue","onUpdate","removeOnRenderRequest","onRenderRequest","scheduleRender","set","initialMotionValues","undefined","isControllingVariants","isVariantNode","current","depth","children","Set","variantChildren","isVisible","manuallyAnimateOnMount","Boolean","mount","newInstance","addVariantChild","forEach","add","setProps","unmount","remove","delete","clearAllListeners","child","closestVariantNode","getClosestVariantNode","other","getInstance","getLayoutId","layoutId","getStaticValue","setStaticValue","getLatestValues","setVisibility","visibility","target","canMutate","addValue","hasValue","removeValue","get","has","getValue","defaultValue","forEachValue","callback","readValue","setBaseTarget","syncRender","newProps","transformTemplate","updatePropListeners","getProps","getVariant","name","variants","getDefaultTransition","transition","getTransformPagePoint","transformPagePoint","getVariantContext","startAtParent","context_1","initial","context","i","numVariantProps","name_1","variantProps","prop","length"],"sources":["C:/Users/hp/Desktop/JavaScript_fullstack_webDev/React/youtube/project2/node_modules/framer-motion/dist/es/render/index.mjs"],"sourcesContent":["import { __assign, __spreadArray, __read } from 'tslib';\nimport sync, { cancelSync } from 'framesync';\nimport { motionValue } from '../value/index.mjs';\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\nimport { variantPriorityOrder } from './utils/animation-state.mjs';\nimport { createLifecycles } from './utils/lifecycles.mjs';\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\nimport { checkIfControllingVariants, checkIfVariantNode, isVariantLabel } from './utils/variants.mjs';\n\nvar visualElement = function (_a) {\n    var _b = _a.treeType, treeType = _b === void 0 ? \"\" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n    return function (_a, options) {\n        var parent = _a.parent, props = _a.props, presenceId = _a.presenceId, blockInitialAnimation = _a.blockInitialAnimation, visualState = _a.visualState, shouldReduceMotion = _a.shouldReduceMotion;\n        if (options === void 0) { options = {}; }\n        var isMounted = false;\n        var latestValues = visualState.latestValues, renderState = visualState.renderState;\n        /**\n         * The instance of the render-specific node that will be hydrated by the\n         * exposed React ref. So for example, this visual element can host a\n         * HTMLElement, plain object, or Three.js object. The functions provided\n         * in VisualElementConfig allow us to interface with this instance.\n         */\n        var instance;\n        /**\n         * Manages the subscriptions for a visual element's lifecycle, for instance\n         * onRender\n         */\n        var lifecycles = createLifecycles();\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        var values = new Map();\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        var valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        var prevMotionValues = {};\n        /**\n         * When values are removed from all animation props we need to search\n         * for a fallback value to animate to. These values are tracked in baseTarget.\n         */\n        var baseTarget = __assign({}, latestValues);\n        // Internal methods ========================\n        /**\n         * On mount, this will be hydrated with a callback to disconnect\n         * this visual element from its parent on unmount.\n         */\n        var removeFromVariantTree;\n        /**\n         * Render the element with the latest styles outside of the React\n         * render lifecycle\n         */\n        function render() {\n            if (!instance || !isMounted)\n                return;\n            triggerBuild();\n            renderInstance(instance, renderState, props.style, element.projection);\n        }\n        function triggerBuild() {\n            build(element, renderState, latestValues, options, props);\n        }\n        function update() {\n            lifecycles.notifyUpdate(latestValues);\n        }\n        /**\n         *\n         */\n        function bindToMotionValue(key, value) {\n            var removeOnChange = value.onChange(function (latestValue) {\n                latestValues[key] = latestValue;\n                props.onUpdate && sync.update(update, false, true);\n            });\n            var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n            valueSubscriptions.set(key, function () {\n                removeOnChange();\n                removeOnRenderRequest();\n            });\n        }\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't neccessarily a breaking change,\n         * more a reflection of the test.\n         */\n        var initialMotionValues = scrapeMotionValuesFromProps(props);\n        for (var key in initialMotionValues) {\n            var value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        var isControllingVariants = checkIfControllingVariants(props);\n        var isVariantNode = checkIfVariantNode(props);\n        var element = __assign(__assign({ treeType: treeType, \n            /**\n             * This is a mirror of the internal instance prop, which keeps\n             * VisualElement type-compatible with React's RefObject.\n             */\n            current: null, \n            /**\n             * The depth of this visual element within the visual element tree.\n             */\n            depth: parent ? parent.depth + 1 : 0, parent: parent, children: new Set(), \n            /**\n             *\n             */\n            presenceId: presenceId, shouldReduceMotion: shouldReduceMotion, \n            /**\n             * If this component is part of the variant tree, it should track\n             * any children that are also part of the tree. This is essentially\n             * a shadow tree to simplify logic around how to stagger over children.\n             */\n            variantChildren: isVariantNode ? new Set() : undefined, \n            /**\n             * Whether this instance is visible. This can be changed imperatively\n             * by the projection tree, is analogous to CSS's visibility in that\n             * hidden elements should take up layout, and needs enacting by the configured\n             * render function.\n             */\n            isVisible: undefined, \n            /**\n             * Normally, if a component is controlled by a parent's variants, it can\n             * rely on that ancestor to trigger animations further down the tree.\n             * However, if a component is created after its parent is mounted, the parent\n             * won't trigger that mount animation so the child needs to.\n             *\n             * TODO: This might be better replaced with a method isParentMounted\n             */\n            manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()), \n            /**\n             * This can be set by AnimatePresence to force components that mount\n             * at the same time as it to mount as if they have initial={false} set.\n             */\n            blockInitialAnimation: blockInitialAnimation, \n            /**\n             * Determine whether this component has mounted yet. This is mostly used\n             * by variant children to determine whether they need to trigger their\n             * own animations on mount.\n             */\n            isMounted: function () { return Boolean(instance); }, mount: function (newInstance) {\n                isMounted = true;\n                instance = element.current = newInstance;\n                if (element.projection) {\n                    element.projection.mount(newInstance);\n                }\n                if (isVariantNode && parent && !isControllingVariants) {\n                    removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n                }\n                values.forEach(function (value, key) { return bindToMotionValue(key, value); });\n                parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n                element.setProps(props);\n            }, \n            /**\n             *\n             */\n            unmount: function () {\n                var _a;\n                (_a = element.projection) === null || _a === void 0 ? void 0 : _a.unmount();\n                cancelSync.update(update);\n                cancelSync.render(render);\n                valueSubscriptions.forEach(function (remove) { return remove(); });\n                removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n                parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n                lifecycles.clearAllListeners();\n                instance = undefined;\n                isMounted = false;\n            }, \n            /**\n             * Add a child visual element to our set of children.\n             */\n            addVariantChild: function (child) {\n                var _a;\n                var closestVariantNode = element.getClosestVariantNode();\n                if (closestVariantNode) {\n                    (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n                    return function () {\n                        return closestVariantNode.variantChildren.delete(child);\n                    };\n                }\n            }, sortNodePosition: function (other) {\n                /**\n                 * If these nodes aren't even of the same type we can't compare their depth.\n                 */\n                if (!sortNodePosition || treeType !== other.treeType)\n                    return 0;\n                return sortNodePosition(element.getInstance(), other.getInstance());\n            }, \n            /**\n             * Returns the closest variant node in the tree starting from\n             * this visual element.\n             */\n            getClosestVariantNode: function () {\n                return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n            }, \n            /**\n             * Expose the latest layoutId prop.\n             */\n            getLayoutId: function () { return props.layoutId; }, \n            /**\n             * Returns the current instance.\n             */\n            getInstance: function () { return instance; }, \n            /**\n             * Get/set the latest static values.\n             */\n            getStaticValue: function (key) { return latestValues[key]; }, setStaticValue: function (key, value) { return (latestValues[key] = value); }, \n            /**\n             * Returns the latest motion value state. Currently only used to take\n             * a snapshot of the visual element - perhaps this can return the whole\n             * visual state\n             */\n            getLatestValues: function () { return latestValues; }, \n            /**\n             * Set the visiblity of the visual element. If it's changed, schedule\n             * a render to reflect these changes.\n             */\n            setVisibility: function (visibility) {\n                if (element.isVisible === visibility)\n                    return;\n                element.isVisible = visibility;\n                element.scheduleRender();\n            }, \n            /**\n             * Make a target animatable by Popmotion. For instance, if we're\n             * trying to animate width from 100px to 100vw we need to measure 100vw\n             * in pixels to determine what we really need to animate to. This is also\n             * pluggable to support Framer's custom value types like Color,\n             * and CSS variables.\n             */\n            makeTargetAnimatable: function (target, canMutate) {\n                if (canMutate === void 0) { canMutate = true; }\n                return makeTargetAnimatable(element, target, props, canMutate);\n            }, \n            /**\n             * Measure the current viewport box with or without transforms.\n             * Only measures axis-aligned boxes, rotate and skew must be manually\n             * removed with a re-render to work.\n             */\n            measureViewportBox: function () {\n                return measureViewportBox(instance, props);\n            }, \n            // Motion values ========================\n            /**\n             * Add a motion value and bind it to this visual element.\n             */\n            addValue: function (key, value) {\n                // Remove existing value if it exists\n                if (element.hasValue(key))\n                    element.removeValue(key);\n                values.set(key, value);\n                latestValues[key] = value.get();\n                bindToMotionValue(key, value);\n            }, \n            /**\n             * Remove a motion value and unbind any active subscriptions.\n             */\n            removeValue: function (key) {\n                var _a;\n                values.delete(key);\n                (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n                valueSubscriptions.delete(key);\n                delete latestValues[key];\n                removeValueFromRenderState(key, renderState);\n            }, \n            /**\n             * Check whether we have a motion value for this key\n             */\n            hasValue: function (key) { return values.has(key); }, \n            /**\n             * Get a motion value for this key. If called with a default\n             * value, we'll create one if none exists.\n             */\n            getValue: function (key, defaultValue) {\n                var value = values.get(key);\n                if (value === undefined && defaultValue !== undefined) {\n                    value = motionValue(defaultValue);\n                    element.addValue(key, value);\n                }\n                return value;\n            }, \n            /**\n             * Iterate over our motion values.\n             */\n            forEachValue: function (callback) { return values.forEach(callback); }, \n            /**\n             * If we're trying to animate to a previously unencountered value,\n             * we need to check for it in our state and as a last resort read it\n             * directly from the instance (which might have performance implications).\n             */\n            readValue: function (key) {\n                var _a;\n                return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options);\n            }, \n            /**\n             * Set the base target to later animate back to. This is currently\n             * only hydrated on creation and when we first read a value.\n             */\n            setBaseTarget: function (key, value) {\n                baseTarget[key] = value;\n            }, \n            /**\n             * Find the base target for a value thats been removed from all animation\n             * props.\n             */\n            getBaseTarget: function (key) {\n                if (getBaseTarget) {\n                    var target = getBaseTarget(props, key);\n                    if (target !== undefined && !isMotionValue(target))\n                        return target;\n                }\n                return baseTarget[key];\n            } }, lifecycles), { \n            /**\n             * Build the renderer state based on the latest visual state.\n             */\n            build: function () {\n                triggerBuild();\n                return renderState;\n            }, \n            /**\n             * Schedule a render on the next animation frame.\n             */\n            scheduleRender: function () {\n                sync.render(render, false, true);\n            }, \n            /**\n             * Synchronously fire render. It's prefered that we batch renders but\n             * in many circumstances, like layout measurement, we need to run this\n             * synchronously. However in those instances other measures should be taken\n             * to batch reads/writes.\n             */\n            syncRender: render, \n            /**\n             * Update the provided props. Ensure any newly-added motion values are\n             * added to our map, old ones removed, and listeners updated.\n             */\n            setProps: function (newProps) {\n                if (newProps.transformTemplate || props.transformTemplate) {\n                    element.scheduleRender();\n                }\n                props = newProps;\n                lifecycles.updatePropListeners(newProps);\n                prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n            }, getProps: function () { return props; }, \n            // Variants ==============================\n            /**\n             * Returns the variant definition with a given name.\n             */\n            getVariant: function (name) { var _a; return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name]; }, \n            /**\n             * Returns the defined default transition on this component.\n             */\n            getDefaultTransition: function () { return props.transition; }, getTransformPagePoint: function () {\n                return props.transformPagePoint;\n            }, \n            /**\n             * Used by child variant nodes to get the closest ancestor variant props.\n             */\n            getVariantContext: function (startAtParent) {\n                if (startAtParent === void 0) { startAtParent = false; }\n                if (startAtParent)\n                    return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n                if (!isControllingVariants) {\n                    var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n                    if (props.initial !== undefined) {\n                        context_1.initial = props.initial;\n                    }\n                    return context_1;\n                }\n                var context = {};\n                for (var i = 0; i < numVariantProps; i++) {\n                    var name_1 = variantProps[i];\n                    var prop = props[name_1];\n                    if (isVariantLabel(prop) || prop === false) {\n                        context[name_1] = prop;\n                    }\n                }\n                return context;\n            } });\n        return element;\n    };\n};\nvar variantProps = __spreadArray([\"initial\"], __read(variantPriorityOrder), false);\nvar numVariantProps = variantProps.length;\n\nexport { visualElement };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}