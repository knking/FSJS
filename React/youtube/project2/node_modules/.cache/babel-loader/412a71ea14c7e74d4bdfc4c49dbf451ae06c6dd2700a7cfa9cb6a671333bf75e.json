{"ast":null,"code":"import { mix, progress, linear, circOut } from 'popmotion';\nimport { px, percent } from 'style-value-types';\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nvar asNumber = function (value) {\n  return typeof value === \"string\" ? parseFloat(value) : value;\n};\nvar isPx = function (value) {\n  return typeof value === \"number\" || px.test(value);\n};\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n  var _a, _b, _c, _d;\n  if (shouldCrossfadeOpacity) {\n    target.opacity = mix(0,\n    // (follow?.opacity as number) ?? 0,\n    // TODO Reinstate this if only child\n    (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1, easeCrossfadeIn(progress));\n    target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress));\n  } else if (isOnlyMember) {\n    target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress);\n  }\n  /**\n   * Mix border radius\n   */\n  for (var i = 0; i < numBorders; i++) {\n    var borderLabel = \"border\".concat(borders[i], \"Radius\");\n    var followRadius = getRadius(follow, borderLabel);\n    var leadRadius = getRadius(lead, borderLabel);\n    if (followRadius === undefined && leadRadius === undefined) continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    var canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);\n    if (canMix) {\n      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n      if (percent.test(leadRadius) || percent.test(followRadius)) {\n        target[borderLabel] += \"%\";\n      }\n    } else {\n      target[borderLabel] = leadRadius;\n    }\n  }\n  /**\n   * Mix rotation\n   */\n  if (follow.rotate || lead.rotate) {\n    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress);\n  }\n}\nfunction getRadius(values, radiusName) {\n  var _a;\n  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\nfunction compress(min, max, easing) {\n  return function (p) {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(progress(min, max, p));\n  };\n}\nexport { mixValues };","map":{"version":3,"names":["mix","progress","linear","circOut","px","percent","borders","numBorders","length","asNumber","value","parseFloat","isPx","test","mixValues","target","follow","lead","shouldCrossfadeOpacity","isOnlyMember","_a","_b","_c","_d","opacity","easeCrossfadeIn","opacityExit","easeCrossfadeOut","i","borderLabel","concat","followRadius","getRadius","leadRadius","undefined","canMix","Math","max","rotate","values","radiusName","borderRadius","compress","min","easing","p"],"sources":["C:/Users/hp/Desktop/JavaScript_fullstack_webDev/React/youtube/project2/node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs"],"sourcesContent":["import { mix, progress, linear, circOut } from 'popmotion';\nimport { px, percent } from 'style-value-types';\n\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nvar asNumber = function (value) {\n    return typeof value === \"string\" ? parseFloat(value) : value;\n};\nvar isPx = function (value) {\n    return typeof value === \"number\" || px.test(value);\n};\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n    var _a, _b, _c, _d;\n    if (shouldCrossfadeOpacity) {\n        target.opacity = mix(0, \n        // (follow?.opacity as number) ?? 0,\n        // TODO Reinstate this if only child\n        (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1, easeCrossfadeIn(progress));\n        target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress));\n    }\n    else if (isOnlyMember) {\n        target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress);\n    }\n    /**\n     * Mix border radius\n     */\n    for (var i = 0; i < numBorders; i++) {\n        var borderLabel = \"border\".concat(borders[i], \"Radius\");\n        var followRadius = getRadius(follow, borderLabel);\n        var leadRadius = getRadius(lead, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        var canMix = followRadius === 0 ||\n            leadRadius === 0 ||\n            isPx(followRadius) === isPx(leadRadius);\n        if (canMix) {\n            target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\n                target[borderLabel] += \"%\";\n            }\n        }\n        else {\n            target[borderLabel] = leadRadius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (follow.rotate || lead.rotate) {\n        target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress);\n    }\n}\nfunction getRadius(values, radiusName) {\n    var _a;\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\nfunction compress(min, max, easing) {\n    return function (p) {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\n\nexport { mixValues };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}