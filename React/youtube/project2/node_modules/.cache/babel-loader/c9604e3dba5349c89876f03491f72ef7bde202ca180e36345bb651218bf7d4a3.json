{"ast":null,"code":"import { __read } from 'tslib';\nimport { mix } from 'popmotion';\nimport { hasTransform } from '../utils/has-transform.mjs';\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n  var distanceFromOrigin = point - originPoint;\n  var scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n  if (scale === void 0) {\n    scale = 1;\n  }\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, _a) {\n  var x = _a.x,\n    y = _a.y;\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition) {\n  var _a, _b;\n  if (isSharedTransition === void 0) {\n    isSharedTransition = false;\n  }\n  var treeLength = treePath.length;\n  if (!treeLength) return;\n  // Reset the treeScale\n  treeScale.x = treeScale.y = 1;\n  var node;\n  var delta;\n  for (var i = 0; i < treeLength; i++) {\n    node = treePath[i];\n    delta = node.projectionDelta;\n    if (((_b = (_a = node.instance) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.display) === \"contents\") continue;\n    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n      transformBox(box, {\n        x: -node.scroll.x,\n        y: -node.scroll.y\n      });\n    }\n    if (delta) {\n      // Incoporate each ancestor's scale into a culmulative treeScale for this component\n      treeScale.x *= delta.x.scale;\n      treeScale.y *= delta.y.scale;\n      // Apply each ancestor's calculated delta into this component's recorded layout box\n      applyBoxDelta(box, delta);\n    }\n    if (isSharedTransition && hasTransform(node.latestValues)) {\n      transformBox(box, node.latestValues);\n    }\n  }\n}\nfunction translateAxis(axis, distance) {\n  axis.min = axis.min + distance;\n  axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, transforms, _a) {\n  var _b = __read(_a, 3),\n    key = _b[0],\n    scaleKey = _b[1],\n    originKey = _b[2];\n  var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n  var originPoint = mix(axis.min, axis.max, axisOrigin);\n  // Apply the axis delta to the final axis\n  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n  transformAxis(box.x, transform, xKeys);\n  transformAxis(box.y, transform, yKeys);\n}\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };","map":{"version":3,"names":["__read","mix","hasTransform","scalePoint","point","scale","originPoint","distanceFromOrigin","scaled","applyPointDelta","translate","boxScale","undefined","applyAxisDelta","axis","min","max","applyBoxDelta","box","_a","x","y","applyTreeDeltas","treeScale","treePath","isSharedTransition","_b","treeLength","length","node","delta","i","projectionDelta","instance","style","display","options","layoutScroll","scroll","root","transformBox","latestValues","translateAxis","distance","transformAxis","transforms","key","scaleKey","originKey","axisOrigin","xKeys","yKeys","transform"],"sources":["C:/Users/hp/Desktop/JavaScript_fullstack_webDev/React/youtube/project2/node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs"],"sourcesContent":["import { __read } from 'tslib';\nimport { mix } from 'popmotion';\nimport { hasTransform } from '../utils/has-transform.mjs';\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    var distanceFromOrigin = point - originPoint;\n    var scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n    if (translate === void 0) { translate = 0; }\n    if (scale === void 0) { scale = 1; }\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, _a) {\n    var x = _a.x, y = _a.y;\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition) {\n    var _a, _b;\n    if (isSharedTransition === void 0) { isSharedTransition = false; }\n    var treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    var node;\n    var delta;\n    for (var i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        if (((_b = (_a = node.instance) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.display) === \"contents\")\n            continue;\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, { x: -node.scroll.x, y: -node.scroll.y });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, transforms, _a) {\n    var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n    var originPoint = mix(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform, xKeys);\n    transformAxis(box.y, transform, yKeys);\n}\n\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}