{"ast":null,"code":"import { __extends, __assign, __read } from 'tslib';\nimport sync from 'framesync';\nimport React__default, { useContext } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\nvar MeasureLayoutWithContext = /** @class */function (_super) {\n  __extends(MeasureLayoutWithContext, _super);\n  function MeasureLayoutWithContext() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * This only mounts projection nodes for components that\n   * need measuring, we might want to do it for all components\n   * in order to incorporate transforms\n   */\n  MeasureLayoutWithContext.prototype.componentDidMount = function () {\n    var _this = this;\n    var _a = this.props,\n      visualElement = _a.visualElement,\n      layoutGroup = _a.layoutGroup,\n      switchLayoutGroup = _a.switchLayoutGroup,\n      layoutId = _a.layoutId;\n    var projection = visualElement.projection;\n    addScaleCorrector(defaultScaleCorrectors);\n    if (projection) {\n      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group) layoutGroup.group.add(projection);\n      if ((switchLayoutGroup === null || switchLayoutGroup === void 0 ? void 0 : switchLayoutGroup.register) && layoutId) {\n        switchLayoutGroup.register(projection);\n      }\n      projection.root.didUpdate();\n      projection.addEventListener(\"animationComplete\", function () {\n        _this.safeToRemove();\n      });\n      projection.setOptions(__assign(__assign({}, projection.options), {\n        onExitComplete: function () {\n          return _this.safeToRemove();\n        }\n      }));\n    }\n    globalProjectionState.hasEverUpdated = true;\n  };\n  MeasureLayoutWithContext.prototype.getSnapshotBeforeUpdate = function (prevProps) {\n    var _this = this;\n    var _a = this.props,\n      layoutDependency = _a.layoutDependency,\n      visualElement = _a.visualElement,\n      drag = _a.drag,\n      isPresent = _a.isPresent;\n    var projection = visualElement.projection;\n    if (!projection) return null;\n    /**\n     * TODO: We use this data in relegate to determine whether to\n     * promote a previous element. There's no guarantee its presence data\n     * will have updated by this point - if a bug like this arises it will\n     * have to be that we markForRelegation and then find a new lead some other way,\n     * perhaps in didUpdate\n     */\n    projection.isPresent = isPresent;\n    if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === undefined) {\n      projection.willUpdate();\n    } else {\n      this.safeToRemove();\n    }\n    if (prevProps.isPresent !== isPresent) {\n      if (isPresent) {\n        projection.promote();\n      } else if (!projection.relegate()) {\n        /**\n         * If there's another stack member taking over from this one,\n         * it's in charge of the exit animation and therefore should\n         * be in charge of the safe to remove. Otherwise we call it here.\n         */\n        sync.postRender(function () {\n          var _a;\n          if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {\n            _this.safeToRemove();\n          }\n        });\n      }\n    }\n    return null;\n  };\n  MeasureLayoutWithContext.prototype.componentDidUpdate = function () {\n    var projection = this.props.visualElement.projection;\n    if (projection) {\n      projection.root.didUpdate();\n      if (!projection.currentAnimation && projection.isLead()) {\n        this.safeToRemove();\n      }\n    }\n  };\n  MeasureLayoutWithContext.prototype.componentWillUnmount = function () {\n    var _a = this.props,\n      visualElement = _a.visualElement,\n      layoutGroup = _a.layoutGroup,\n      promoteContext = _a.switchLayoutGroup;\n    var projection = visualElement.projection;\n    if (projection) {\n      projection.scheduleCheckAfterUnmount();\n      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group) layoutGroup.group.remove(projection);\n      if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister) promoteContext.deregister(projection);\n    }\n  };\n  MeasureLayoutWithContext.prototype.safeToRemove = function () {\n    var safeToRemove = this.props.safeToRemove;\n    safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();\n  };\n  MeasureLayoutWithContext.prototype.render = function () {\n    return null;\n  };\n  return MeasureLayoutWithContext;\n}(React__default.Component);\nfunction MeasureLayout(props) {\n  var _a = __read(usePresence(), 2),\n    isPresent = _a[0],\n    safeToRemove = _a[1];\n  var layoutGroup = useContext(LayoutGroupContext);\n  return React__default.createElement(MeasureLayoutWithContext, __assign({}, props, {\n    layoutGroup: layoutGroup,\n    switchLayoutGroup: useContext(SwitchLayoutGroupContext),\n    isPresent: isPresent,\n    safeToRemove: safeToRemove\n  }));\n}\nvar defaultScaleCorrectors = {\n  borderRadius: __assign(__assign({}, correctBorderRadius), {\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  }),\n  borderTopLeftRadius: correctBorderRadius,\n  borderTopRightRadius: correctBorderRadius,\n  borderBottomLeftRadius: correctBorderRadius,\n  borderBottomRightRadius: correctBorderRadius,\n  boxShadow: correctBoxShadow\n};\nexport { MeasureLayout };","map":{"version":3,"names":["__extends","__assign","__read","sync","React__default","useContext","usePresence","LayoutGroupContext","SwitchLayoutGroupContext","globalProjectionState","correctBorderRadius","correctBoxShadow","addScaleCorrector","MeasureLayoutWithContext","_super","apply","arguments","prototype","componentDidMount","_this","_a","props","visualElement","layoutGroup","switchLayoutGroup","layoutId","projection","defaultScaleCorrectors","group","add","register","root","didUpdate","addEventListener","safeToRemove","setOptions","options","onExitComplete","hasEverUpdated","getSnapshotBeforeUpdate","prevProps","layoutDependency","drag","isPresent","undefined","willUpdate","promote","relegate","postRender","getStack","members","length","componentDidUpdate","currentAnimation","isLead","componentWillUnmount","promoteContext","scheduleCheckAfterUnmount","remove","deregister","render","Component","MeasureLayout","createElement","borderRadius","applyTo","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","boxShadow"],"sources":["C:/Users/hp/Desktop/JavaScript_fullstack_webDev/React/youtube/project2/node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs"],"sourcesContent":["import { __extends, __assign, __read } from 'tslib';\nimport sync from 'framesync';\nimport React__default, { useContext } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\n\nvar MeasureLayoutWithContext = /** @class */ (function (_super) {\n    __extends(MeasureLayoutWithContext, _super);\n    function MeasureLayoutWithContext() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */\n    MeasureLayoutWithContext.prototype.componentDidMount = function () {\n        var _this = this;\n        var _a = this.props, visualElement = _a.visualElement, layoutGroup = _a.layoutGroup, switchLayoutGroup = _a.switchLayoutGroup, layoutId = _a.layoutId;\n        var projection = visualElement.projection;\n        addScaleCorrector(defaultScaleCorrectors);\n        if (projection) {\n            if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)\n                layoutGroup.group.add(projection);\n            if ((switchLayoutGroup === null || switchLayoutGroup === void 0 ? void 0 : switchLayoutGroup.register) && layoutId) {\n                switchLayoutGroup.register(projection);\n            }\n            projection.root.didUpdate();\n            projection.addEventListener(\"animationComplete\", function () {\n                _this.safeToRemove();\n            });\n            projection.setOptions(__assign(__assign({}, projection.options), { onExitComplete: function () { return _this.safeToRemove(); } }));\n        }\n        globalProjectionState.hasEverUpdated = true;\n    };\n    MeasureLayoutWithContext.prototype.getSnapshotBeforeUpdate = function (prevProps) {\n        var _this = this;\n        var _a = this.props, layoutDependency = _a.layoutDependency, visualElement = _a.visualElement, drag = _a.drag, isPresent = _a.isPresent;\n        var projection = visualElement.projection;\n        if (!projection)\n            return null;\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There's no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */\n        projection.isPresent = isPresent;\n        if (drag ||\n            prevProps.layoutDependency !== layoutDependency ||\n            layoutDependency === undefined) {\n            projection.willUpdate();\n        }\n        else {\n            this.safeToRemove();\n        }\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote();\n            }\n            else if (!projection.relegate()) {\n                /**\n                 * If there's another stack member taking over from this one,\n                 * it's in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */\n                sync.postRender(function () {\n                    var _a;\n                    if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {\n                        _this.safeToRemove();\n                    }\n                });\n            }\n        }\n        return null;\n    };\n    MeasureLayoutWithContext.prototype.componentDidUpdate = function () {\n        var projection = this.props.visualElement.projection;\n        if (projection) {\n            projection.root.didUpdate();\n            if (!projection.currentAnimation && projection.isLead()) {\n                this.safeToRemove();\n            }\n        }\n    };\n    MeasureLayoutWithContext.prototype.componentWillUnmount = function () {\n        var _a = this.props, visualElement = _a.visualElement, layoutGroup = _a.layoutGroup, promoteContext = _a.switchLayoutGroup;\n        var projection = visualElement.projection;\n        if (projection) {\n            projection.scheduleCheckAfterUnmount();\n            if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)\n                layoutGroup.group.remove(projection);\n            if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)\n                promoteContext.deregister(projection);\n        }\n    };\n    MeasureLayoutWithContext.prototype.safeToRemove = function () {\n        var safeToRemove = this.props.safeToRemove;\n        safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();\n    };\n    MeasureLayoutWithContext.prototype.render = function () {\n        return null;\n    };\n    return MeasureLayoutWithContext;\n}(React__default.Component));\nfunction MeasureLayout(props) {\n    var _a = __read(usePresence(), 2), isPresent = _a[0], safeToRemove = _a[1];\n    var layoutGroup = useContext(LayoutGroupContext);\n    return (React__default.createElement(MeasureLayoutWithContext, __assign({}, props, { layoutGroup: layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove })));\n}\nvar defaultScaleCorrectors = {\n    borderRadius: __assign(__assign({}, correctBorderRadius), { applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ] }),\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow,\n};\n\nexport { MeasureLayout };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}